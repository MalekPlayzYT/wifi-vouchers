<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Toy Town Helper â€” Mobile</title>
<style>
  :root{
    --ink:#1a1a1a;
    --panel:#ffffffee;
    --stroke:#00000014;
    --shadow: 0 14px 40px rgba(0,0,0,.20);
    --shadow2: 0 20px 60px rgba(0,0,0,.28);
  }
  html,body{height:100%;margin:0;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    background:#bff2ff; touch-action:none; -webkit-user-select:none; user-select:none;}
  #app{position:fixed; inset:0; display:flex; flex-direction:column;}
  #top{display:flex; gap:10px; align-items:center; justify-content:space-between; padding:10px; padding-top:calc(10px + env(safe-area-inset-top));}
  .card{
    background:var(--panel);
    border:4px solid var(--stroke);
    border-radius:24px;
    box-shadow:var(--shadow);
    backdrop-filter: blur(6px);
  }
  #status{
    flex:1; display:flex; align-items:center; gap:12px;
    padding:10px 12px; min-height:74px;
  }
  #face{
    width:60px;height:60px;border-radius:18px;
    display:grid;place-items:center;font-size:36px;
    background:#fff;border:4px solid #00000010;
    box-shadow: inset 0 -8px 0 rgba(0,0,0,.06);
  }
  #texts{min-width:0}
  #title{font-weight:1000; font-size:18px; color:var(--ink); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  #sub{font-weight:850; font-size:14px; opacity:.72; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  #buttons{display:flex; gap:10px;}
  .bigbtn{
    width:74px;height:74px;border-radius:26px;
    border:4px solid #00000010; background:#fff;
    box-shadow:var(--shadow);
    display:grid;place-items:center;
    font-size:34px;
    cursor:pointer; -webkit-tap-highlight-color:transparent;
  }
  .bigbtn:active{transform: translateY(1px) scale(.99);}

  #stage{
    flex:1; position:relative; margin:0 10px 10px;
    border-radius:28px; overflow:hidden;
    border:5px solid #00000010; box-shadow:var(--shadow2);
    background: linear-gradient(180deg, rgba(255,255,255,.55), rgba(255,255,255,.22));
  }
  canvas{width:100%;height:100%;display:block;}

  .overlay{
    position:absolute; inset:0;
    display:none;
    background: rgba(0,0,0,.18);
    backdrop-filter: blur(3px);
  }
  .overlay.show{display:flex;}

  .panel{
    margin:auto;
    width:min(920px, 94vw);
    max-height: 90vh;
    overflow:auto;
    padding:14px;
    border-radius:28px;
    background: var(--panel);
    border:5px solid var(--stroke);
    box-shadow:var(--shadow2);
  }

  .row{display:flex; gap:12px; flex-wrap:wrap;}
  .h1{font-weight:1000; font-size:22px; color:var(--ink); margin:6px 0 10px;}
  .hint{font-weight:850; opacity:.72; margin-bottom:10px;}
  .tile{
    flex:1; min-width: 240px;
    padding:12px;
    border-radius:24px;
    border:4px solid #00000010;
    background:#fff;
    box-shadow: var(--shadow);
  }
  .tileTitle{font-weight:1000; font-size:16px; margin-bottom:10px;}
  .picker{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
  .swatch{
    width:54px;height:54px;border-radius:18px;
    border:4px solid #00000010;
    cursor:pointer;
    box-shadow: inset 0 -8px 0 rgba(0,0,0,.06);
    display:grid; place-items:center;
  }
  .swatch:active{transform: translateY(1px) scale(.99);}
  .sliderBox{display:flex; align-items:center; gap:10px;}
  input[type="range"]{width:100%}
  .closeRow{display:flex; justify-content:space-between; gap:10px; margin-top:12px;}
  .pill{
    flex:1;
    padding:14px 14px;
    border-radius:22px;
    border:4px solid #00000010;
    background:#fff;
    box-shadow:var(--shadow);
    font-weight:1000;
    font-size:18px;
    cursor:pointer;
  }
  .pill:active{transform: translateY(1px) scale(.99);}

  #previewBox{display:flex; gap:12px; align-items:center;}
  #previewCanvas{
    width:180px; height:120px;
    border-radius:22px;
    border:4px solid rgba(0,0,0,.10);
    background: linear-gradient(180deg, rgba(94,194,255,.20), rgba(255,255,255,.85));
    box-shadow: inset 0 -10px 0 rgba(0,0,0,.04);
  }
  #previewInfo{font-weight:900; opacity:.78;}

  #miniOverlay .panel{padding:0; overflow:hidden;}
  #miniHeader{
    display:flex; align-items:center; justify-content:space-between;
    padding:12px;
    border-bottom:4px solid #00000010;
    background:#fff;
  }
  #miniName{font-weight:1000; font-size:18px;}
  #miniArea{
    position:relative;
    height: min(620px, 76vh);
    background: linear-gradient(180deg, rgba(255,255,255,.70), rgba(255,255,255,.25));
    overflow:hidden;
  }
  #miniArea *{touch-action:none;}
  .miniBtn{
    width:70px;height:70px;border-radius:24px;
    border:4px solid #00000010;background:#fff;
    box-shadow:var(--shadow);
    font-size:30px; display:grid; place-items:center;
    cursor:pointer;
  }
  .miniBtn:active{transform: translateY(1px) scale(.99);}

  #toast{
    position:absolute; left:50%; top:14%;
    transform: translateX(-50%);
    padding:12px 16px;
    border-radius:26px;
    border:5px solid #00000010;
    background:#fff;
    box-shadow:var(--shadow2);
    font-weight:1000;
    font-size:28px;
    display:none;
    pointer-events:none;
  }
  #toast.show{display:block;}

  /* Mobile: bigger tap targets, less text */
  @media (max-width: 520px){
    #title{font-size:16px}
    #sub{font-size:13px}
    .bigbtn{width:68px;height:68px;border-radius:24px;font-size:32px}
    #status{min-height:70px}
    #face{width:56px;height:56px;border-radius:16px}
    .pill{font-size:17px}
  }

  /* Landscape phone: make top bar compact + bigger play area */
  @media (orientation: landscape) and (max-height: 520px){
    #top{padding:8px; padding-top:calc(6px + env(safe-area-inset-top)); gap:8px;}
    #status{min-height:56px; padding:8px 10px; border-radius:22px;}
    #face{width:46px;height:46px;border-radius:14px;font-size:28px}
    #title{font-size:14px}
    #sub{font-size:12px}
    .bigbtn{width:56px;height:56px;border-radius:20px;font-size:26px}
    #stage{margin:0 8px 8px; border-radius:24px}
    .panel{max-height:92vh}
    /* Garage: stack preview + controls nicer in landscape */
    #previewCanvas{width:160px;height:106px}
    .tile{min-width: 200px}
  }

</style>
</head>
<body>
<div id="app">
  <div id="top">
    <div id="status" class="card">
      <div id="face">ğŸš—</div>
      <div id="texts">
        <div id="title">Toy Town Helper</div>
        <div id="sub">Tap the HELP bubble â†’ mini-game â†’ next HELP!</div>
      </div>
    </div>
    <div id="buttons">
      <button class="bigbtn" id="garageBtn" title="Garage">ğŸ¨</button>
      <button class="bigbtn" id="hornBtn" title="Honk">ğŸ“£</button>
    </div>
  </div>

  <div id="stage">
    <canvas id="c"></canvas>
    <div id="toast">YAY! ğŸ‰</div>

    <div id="garageOverlay" class="overlay">
      <div class="panel">
        <div class="h1">Garage ğŸ¨</div>
        <div class="hint">Preview âœ… Color â€¢ Size â€¢ Wheels â€¢ Horn</div>

        <div class="row">
          <div class="tile">
            <div class="tileTitle">Car Preview</div>
            <div id="previewBox">
              <canvas id="previewCanvas" width="360" height="240"></canvas>
              <div id="previewInfo">
                Tap ğŸ“£ to test horn.<br/>
                Make it BIG or TINY.<br/>
                Then press PLAY ğŸš—
              </div>
            </div>
          </div>

          <div class="tile">
            <div class="tileTitle">Color</div>
            <div class="picker" id="colorPicker"></div>
          </div>

          <div class="tile">
            <div class="tileTitle">Car Size</div>
            <div class="sliderBox">
              <span style="font-weight:1000;">ğŸ­</span>
              <input id="sizeRange" type="range" min="0.7" max="1.9" step="0.05" value="1.0"/>
              <span style="font-weight:1000;">ğŸ¦–</span>
            </div>
          </div>

          <div class="tile">
            <div class="tileTitle">Wheels</div>
            <div class="sliderBox">
              <span style="font-weight:1000;">ğŸ›</span>
              <input id="wheelRange" type="range" min="0.7" max="2.2" step="0.05" value="1.0"/>
              <span style="font-weight:1000;">ğŸ›</span>
            </div>
          </div>

          <div class="tile">
            <div class="tileTitle">Horn</div>
            <div class="picker" id="hornPicker"></div>
          </div>
        </div>

        <div class="closeRow">
          <button class="pill" id="closeGarage">PLAY! ğŸš—</button>
          <button class="pill" id="randomize">RANDOM âœ¨</button>
        </div>
      </div>
    </div>

    <div id="miniOverlay" class="overlay">
      <div class="panel">
        <div id="miniHeader">
          <div id="miniName">Mini-game</div>
          <button class="miniBtn" id="miniExit" title="Exit">âŒ</button>
        </div>
        <div id="miniArea"></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);

  const canvas = $("c");
  const ctx = canvas.getContext("2d");
  const stage = $("stage");

  const face  = $("face");
  const title = $("title");
  const sub   = $("sub");
  const toast = $("toast");

  const garageOverlay = $("garageOverlay");
  const garageBtn = $("garageBtn");
  const closeGarage = $("closeGarage");
  const randomizeBtn = $("randomize");

  const colorPicker = $("colorPicker");
  const hornPicker  = $("hornPicker");
  const sizeRange   = $("sizeRange");
  const wheelRange  = $("wheelRange");
  const hornBtn = $("hornBtn");

  const miniOverlay = $("miniOverlay");
  const miniArea = $("miniArea");
  const miniName = $("miniName");
  const miniExit = $("miniExit");

  const previewCanvas = $("previewCanvas");
  const pctx = previewCanvas.getContext("2d");

  // ===== Old Map (smaller) =====
  const world = { w: 1800, h: 1200 };
  const view  = { w: 1200, h: 780 }; // recalculated to screen aspect
  const cam = { x: 300, y: 600 };

  function updateViewToScreen(){
    const dpr = canvas._dpr || 1;
    const cw = canvas.width / dpr;
    const ch = canvas.height / dpr;
    const aspect = cw / ch;
    view.h = 760;               // zoom-out amount (smaller map)
    view.w = view.h * aspect;   // always fits screen âœ…
  }

  function resize(){
    const dpr = Math.max(1, Math.min(2, devicePixelRatio || 1));
    canvas.width  = Math.floor(stage.clientWidth  * dpr);
    canvas.height = Math.floor(stage.clientHeight * dpr);
    canvas._dpr = dpr;
    updateViewToScreen();
  }
  addEventListener("resize", resize, {passive:true});

  // ===== Sound =====
  let audioCtx = null;
  function beep(freq=600, dur=0.08, gain=0.05, type="sine"){
    try{
      if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + dur);
    }catch(e){}
  }
  const Horns = [
    {id:"beep", icon:"ğŸš—", play:()=>{beep(520,0.08,0.05); setTimeout(()=>beep(390,0.10,0.05),90);} },
    {id:"toot", icon:"ğŸº", play:()=>{beep(740,0.06,0.05,"triangle"); setTimeout(()=>beep(660,0.08,0.05,"triangle"),70);} },
    {id:"boop", icon:"ğŸ¤–", play:()=>{beep(330,0.07,0.05,"square"); setTimeout(()=>beep(440,0.07,0.04,"square"),80);} },
    {id:"ding", icon:"ğŸ””", play:()=>{beep(880,0.06,0.045); setTimeout(()=>beep(990,0.08,0.04),80);} },
    {id:"woo",  icon:"ğŸš¨", play:()=>{beep(740,0.10,0.04); setTimeout(()=>beep(540,0.10,0.04),110); setTimeout(()=>beep(740,0.10,0.04),220);} },
  ];
  function happy(){ beep(900,0.06,0.05); setTimeout(()=>beep(1050,0.07,0.045),90); }

  // ===== UI =====
  function showToast(text){
    toast.textContent = text;
    toast.classList.add("show");
    setTimeout(()=>toast.classList.remove("show"), 650);
  }

  // ===== Camera transforms =====
  function fit(){
    const dpr = canvas._dpr || 1;
    const cw = canvas.width, ch = canvas.height;
    const pad = 16*dpr;
    const sx = (cw - pad*2) / view.w;
    const sy = (ch - pad*2) / view.h;
    const s = Math.min(sx, sy);
    const ox = (cw - view.w*s) / 2;
    const oy = (ch - view.h*s) / 2;
    return {ox,oy,s};
  }
  function W2C(x,y){
    const {ox,oy,s} = fit();
    const vx = x - cam.x + view.w/2;
    const vy = y - cam.y + view.h/2;
    return {x: ox + vx*s, y: oy + vy*s, s};
  }
  function C2W(px,py){
    const {ox,oy,s} = fit();
    const vx = (px - ox) / s;
    const vy = (py - oy) / s;
    return {x: vx + cam.x - view.w/2, y: vy + cam.y - view.h/2};
  }
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);
  function lerpAngle(a,b,t){
    const diff = Math.atan2(Math.sin(b-a), Math.cos(b-a));
    return a + diff*t;
  }

  // ===== Car customization =====
  const car = {
    x: 240, y: 620, heading: 0,
    color: "#5ec2ff",
    size: 1.0,
    wheel: 1.0,
    hornId: "beep",
  };
  const CarColors = ["#ff4fa3","#5ec2ff","#7cffb2","#ffd27c","#b48cff","#ffb36b","#ffffff","#222222","#ff3b30","#34c759"];
  function currentHorn(){ return Horns.find(h=>h.id===car.hornId) || Horns[0]; }

  function previewDraw(){
    const W = previewCanvas.width, H = previewCanvas.height;
    pctx.clearRect(0,0,W,H);
    pctx.fillStyle = "rgba(255,255,255,.8)";
    pctx.fillRect(0,0,W,H);

    const cx = W*0.50, cy = H*0.58;
    const s = 1.25 * car.size;

    pctx.fillStyle = "rgba(0,0,0,.14)";
    pctx.beginPath(); pctx.ellipse(cx, cy+55*s, 90*s, 26*s, 0, 0, Math.PI*2); pctx.fill();

    pctx.fillStyle = car.color;
    pctx.strokeStyle = "rgba(0,0,0,.12)";
    pctx.lineWidth = 10*s;
    rr(cx-110*s, cy-60*s, 220*s, 140*s, 60*s);
    pctx.fill(); pctx.stroke();

    pctx.fillStyle = "rgba(255,255,255,.55)";
    rr(cx-20*s, cy-55*s, 90*s, 70*s, 35*s);
    pctx.fill();

    const ws = s * car.wheel;
    pctx.fillStyle = "rgba(0,0,0,.35)";
    pctx.beginPath(); pctx.arc(cx-70*s, cy+75*s, 22*ws, 0, Math.PI*2); pctx.fill();
    pctx.beginPath(); pctx.arc(cx+70*s, cy+75*s, 22*ws, 0, Math.PI*2); pctx.fill();

    pctx.font = `28px system-ui, Apple Color Emoji, Segoe UI Emoji`;
    pctx.textAlign="left"; pctx.textBaseline="top";
    const icon = (Horns.find(h=>h.id===car.hornId)?.icon) || "ğŸ“£";
    pctx.fillStyle = "rgba(0,0,0,.35)";
    pctx.fillText(`Horn: ${icon}`, 14, 14);

    function rr(x,y,w,h,r){
      const rr = Math.min(r,w/2,h/2);
      pctx.beginPath();
      pctx.moveTo(x+rr,y);
      pctx.arcTo(x+w,y,x+w,y+h,rr);
      pctx.arcTo(x+w,y+h,x,y+h,rr);
      pctx.arcTo(x,y+h,x,y,rr);
      pctx.arcTo(x,y,x+w,y,rr);
      pctx.closePath();
    }
  }

  function buildGarageUI(){
    colorPicker.innerHTML = "";
    CarColors.forEach(col=>{
      const b = document.createElement("button");
      b.className="swatch";
      b.style.background = col;
      b.onclick = ()=>{ car.color=col; previewDraw(); };
      colorPicker.appendChild(b);
    });

    hornPicker.innerHTML = "";
    Horns.forEach(h=>{
      const b = document.createElement("button");
      b.className="swatch";
      b.style.background="#fff";
      b.innerHTML = `<div style="font-size:28px">${h.icon}</div>`;
      b.onclick = ()=>{ car.hornId=h.id; h.play(); previewDraw(); };
      hornPicker.appendChild(b);
    });

    sizeRange.value = car.size;
    wheelRange.value = car.wheel;
    previewDraw();
  }

  garageBtn.onclick = ()=>{ buildGarageUI(); garageOverlay.classList.add("show"); };
  closeGarage.onclick = ()=>{ garageOverlay.classList.remove("show"); };
  randomizeBtn.onclick = ()=>{
    car.color = CarColors[Math.floor(Math.random()*CarColors.length)];
    car.size  = 0.7 + Math.random()*1.0;
    car.wheel = 0.7 + Math.random()*1.2;
    car.hornId = Horns[Math.floor(Math.random()*Horns.length)].id;
    sizeRange.value = car.size;
    wheelRange.value = car.wheel;
    currentHorn().play();
    previewDraw();
    showToast("WOW! âœ¨");
  };
  sizeRange.oninput = ()=>{ car.size = parseFloat(sizeRange.value); previewDraw(); };
  wheelRange.oninput = ()=>{ car.wheel = parseFloat(wheelRange.value); previewDraw(); };
  hornBtn.onclick = ()=> currentHorn().play();

  // ===== Town Toys =====
  const toys = [
    {x:240,y:620,w:180,h:160,emoji:"ğŸ ",bounce:0, z:1},
    {x:560,y:360,w:260,h:190,emoji:"ğŸª",bounce:0, z:1},
    {x:860,y:720,w:260,h:190,emoji:"ğŸŒ³",bounce:0, z:1},
    {x:1110,y:420,w:320,h:240,emoji:"ğŸ°",bounce:0, z:3},
    {x:1200,y:840,w:260,h:190,emoji:"ğŸ¦†",bounce:0, z:1},
    {x:1480,y:640,w:260,h:190,emoji:"ğŸ¦",bounce:0, z:1},
    {x:1520,y:980,w:260,h:190,emoji:"ğŸš‚",bounce:0, z:1},
    {x:420,y:980,w:260,h:190,emoji:"ğŸ§¸",bounce:0, z:1},
  ];
  function hitToy(wx,wy){
    let best=null;
    for(const t of toys){
      if(Math.abs(wx-t.x) < t.w/2 && Math.abs(wy-t.y) < t.h/2){
        if(!best || (t.z||0) > (best.z||0)) best=t;
      }
    }
    return best;
  }

  // ===== Mini-game Safety (fix "2nd time" bugs) =====
  const MiniGames = [];
  let miniSessionId = 0;
  let miniCleanups = [];

  function miniNewSession(){
    for(const fn of miniCleanups) { try{ fn(); }catch(e){} }
    miniCleanups = [];
    miniSessionId++;
    return miniSessionId;
  }
  function miniSetTimeout(fn, ms, sid){
    const id = setTimeout(()=>{ if(sid===miniSessionId) fn(); }, ms);
    miniCleanups.push(()=>clearTimeout(id));
    return id;
  }
  function miniSetInterval(fn, ms, sid){
    const id = setInterval(()=>{ if(sid===miniSessionId) fn(); }, ms);
    miniCleanups.push(()=>clearInterval(id));
    return id;
  }
  function miniRAF(fn, sid){
    let rafId=0;
    const step = (t)=>{ if(sid!==miniSessionId) return; fn(t); rafId=requestAnimationFrame(step); };
    rafId=requestAnimationFrame(step);
    miniCleanups.push(()=>cancelAnimationFrame(rafId));
  }
  function clearMiniArea(){
    miniNewSession();
    miniArea.innerHTML = "";
    miniArea.onclick = null;
    miniArea.onpointerdown = null;
    miniArea.onpointermove = null;
    miniArea.onpointerup = null;
    miniArea.onpointercancel = null;
  }

  function addMiniTip(container, text){
    const tip = document.createElement("div");
    tip.textContent = text;
    tip.style.cssText = `
      position:absolute; left:50%; top:14px; transform:translateX(-50%);
      padding:10px 14px; border-radius: 22px;
      background:#fff; border:4px solid rgba(0,0,0,.10);
      box-shadow: 0 14px 40px rgba(0,0,0,.20);
      font-weight:1000; font-size:22px; user-select:none;
    `;
    container.appendChild(tip);
  }

  function startMiniGame(id, onWin){
    const mg = MiniGames.find(g=>g.id===id) || MiniGames[0];
    miniName.textContent = mg.name;
    clearMiniArea();
    miniOverlay.classList.add("show");

    const sid = miniSessionId;
    try{
      mg.start(miniArea, ()=>{
        if(sid !== miniSessionId) return;
        happy();
        miniOverlay.classList.remove("show");
        clearMiniArea();
        onWin?.();
      }, sid);
    }catch(e){
      miniOverlay.classList.remove("show");
      clearMiniArea();
      onWin?.();
    }
  }
  miniExit.onclick = ()=>{ miniOverlay.classList.remove("show"); clearMiniArea(); };

  // ===== Solid Minigames (ALL reset-safe + mobile-tap friendly) =====

  // Helper: create a tap-to-pop spawning game with lots of targets
  function createTapSpawnGame(opts){
    const {
      id, name, emoji, needed=12,
      burst=14, minSize=64, maxSize=92,
      lifeMs=0, float=false, drift=false, bg="radial-gradient(circle at 35% 30%, #ffffffcc, #5ec2ff)",
      label="TAP",
      respawnWhenLow=8,
    } = opts;

    MiniGames.push({
      id, name,
      start(container, win, sid){
        container.style.position="relative";
        addMiniTip(container, `${label} ${emoji}`);
        let count=0;

        function spawnOne(){
          const W=container.clientWidth, H=container.clientHeight;
          const el=document.createElement("div");
          el.textContent=emoji;
          const x=rand(60,W-60), y=rand(140,H-80), s=rand(minSize,maxSize);
          el.style.cssText=`
            position:absolute; left:${x}px; top:${y}px; transform:translate(-50%,-50%);
            width:${s}px; height:${s}px; border-radius:999px;
            background:${bg};
            border:4px solid rgba(0,0,0,.10);
            box-shadow:0 12px 28px rgba(0,0,0,.18);
            display:grid; place-items:center; font-size:${Math.round(s*0.32)}px;
          `;
          el.classList.add("tapItem");
          container.appendChild(el);

          // optional life timeout
          if(lifeMs>0) miniSetTimeout(()=>{ if(el.isConnected) el.remove(); }, lifeMs, sid);

          // optional motion
          if(float || drift){
            let xx=x, yy=y;
            const vy = float ? rand(-26,-12) : rand(-10,10);
            const vx = drift ? rand(-40,40) : 0;
            miniRAF(()=>{
              if(sid!==miniSessionId || !el.isConnected) return;
              xx += vx*0.016;
              yy += vy*0.016;
              if(xx<60) xx=W-60;
              if(xx>W-60) xx=60;
              if(yy<115) yy=H-80;
              if(yy>H-80) yy=140;
              el.style.left = xx+"px";
              el.style.top  = yy+"px";
            }, sid);
          }

          el.onclick=()=>{
            if(sid!==miniSessionId) return;
            el.remove();
            beep(760,0.05,0.04);
            count++;
            if(count>=needed) return win();
            // keep game "busy"
            if(container.querySelectorAll(".tapItem").length < respawnWhenLow){
              for(let i=0;i<6;i++) miniSetTimeout(spawnOne, i*55, sid);
            }
          };
        }

        for(let i=0;i<burst;i++) miniSetTimeout(spawnOne, i*70, sid);

        // safety: keep spawning if player is too fast
        miniSetInterval(()=>{
          if(sid!==miniSessionId) return;
          const n = container.querySelectorAll(".tapItem").length;
          if(n < respawnWhenLow) spawnOne();
        }, 420, sid);
      }
    });
  }

  // Helper: create a simple "tap big one" game
  function createTapBigOneGame(id, name, goodEmoji, badEmoji){
    MiniGames.push({
      id, name,
      start(container, win, sid){
        container.style.position="relative";
        addMiniTip(container, `TAP ${goodEmoji} (NOT ${badEmoji})`);
        let score=0, needed=10;

        function round(){
          if(sid!==miniSessionId) return;
          container.querySelectorAll(".choice").forEach(e=>e.remove());
          const badIndex = Math.floor(Math.random()*6);

          for(let i=0;i<6;i++){
            const el=document.createElement("div");
            el.className="choice";
            el.textContent=(i===badIndex) ? badEmoji : goodEmoji;
            el.style.cssText=`position:absolute; left:${rand(15,85)}%; top:${rand(26,88)}%;
              transform:translate(-50%,-50%); font-size:${(i===badIndex)?78:88}px; user-select:none;`;
            container.appendChild(el);
            el.onclick=()=>{
              if(sid!==miniSessionId) return;
              if(el.textContent===goodEmoji){
                beep(990,0.06,0.04);
                score++;
                if(score>=needed) win(); else round();
              }else beep(220,0.08,0.05);
            };
          }
        }
        round();
      }
    });
  }

  // Keep your original strong games (re-added, fixed)
  createTapSpawnGame({id:"balloons", name:"Pop Balloons ğŸˆ", emoji:"ğŸˆ", needed:18, burst:22, bg:"radial-gradient(circle at 35% 30%, #ffffffcc, #ff4fa3)", label:"TAP", float:true});
  createTapSpawnGame({id:"stars", name:"Catch Stars â­", emoji:"â­", needed:14, burst:10, bg:"radial-gradient(circle at 35% 30%, #ffffffcc, #ffd27c)", label:"TAP", drift:true, respawnWhenLow:5, minSize:54, maxSize:78});
  createTapSpawnGame({id:"coinsTap", name:"Tap Coins ğŸª™", emoji:"ğŸª™", needed:16, burst:14, bg:"radial-gradient(circle at 35% 30%, #ffffffcc, #ffd60a)", label:"TAP", drift:true, respawnWhenLow:6, minSize:56, maxSize:86});
  createTapBigOneGame("happyFace", "Tap Happy ğŸ˜€ (Not ğŸ˜´)", "ğŸ˜€", "ğŸ˜´");

  // Press The Color (same as before)
  MiniGames.push({
    id:"colors", name:"Press The Color ğŸŸ¥ğŸŸ¦ğŸŸ¨",
    start(container, win, sid){
      container.style.position="relative";
      const colors=[
        {emoji:"ğŸŸ¥", bg:"#ff3b30"},
        {emoji:"ğŸŸ¦", bg:"#0a84ff"},
        {emoji:"ğŸŸ¨", bg:"#ffd60a"},
        {emoji:"ğŸŸ©", bg:"#34c759"},
      ];
      let score=0, needed=10;
      let target = colors[Math.floor(Math.random()*colors.length)];
      addMiniTip(container, `PRESS ${target.emoji}`);

      const row=document.createElement("div");
      row.style.cssText=`position:absolute; left:50%; top:56%; transform:translate(-50%,-50%);
        display:flex; gap:14px; flex-wrap:wrap; justify-content:center;`;
      container.appendChild(row);

      function setNewTarget(){
        target = colors[Math.floor(Math.random()*colors.length)];
        container.firstChild.textContent = `PRESS ${target.emoji}`;
      }

      colors.forEach(c=>{
        const b=document.createElement("button");
        b.style.cssText=`
          width: min(42vw, 150px); height:min(42vw, 150px);
          border-radius:44px; border:4px solid rgba(0,0,0,.10);
          box-shadow: 0 14px 40px rgba(0,0,0,.20);
          background:${c.bg}; font-size:56px; cursor:pointer;
        `;
        b.textContent=c.emoji;
        b.onclick=()=>{
          if(sid!==miniSessionId) return;
          if(c.emoji===target.emoji){
            beep(990,0.06,0.04);
            score++;
            if(score>=needed) win(); else setNewTarget();
          }else beep(220,0.08,0.05);
        };
        row.appendChild(b);
      });
    }
  });

  // Match Shapes (drag)
  MiniGames.push({
    id:"match", name:"Match Shapes ğŸ§©",
    start(container, win, sid){
      container.style.position="relative";
      const W=container.clientWidth, H=container.clientHeight;
      addMiniTip(container, "DRAG ğŸ§© TO MATCH");
      let done=0;

      const targets = [
        {emoji:"ğŸŸ¥", x: W*0.78, y: H*0.34},
        {emoji:"ğŸŸ¦", x: W*0.82, y: H*0.58},
        {emoji:"ğŸŸ¨", x: W*0.74, y: H*0.80},
      ];
      const pieces = [
        {emoji:"ğŸŸ¥", x: W*0.22, y: H*0.34},
        {emoji:"ğŸŸ¦", x: W*0.20, y: H*0.58},
        {emoji:"ğŸŸ¨", x: W*0.24, y: H*0.80},
      ];

      for(const t of targets){
        const el=document.createElement("div");
        el.textContent=t.emoji;
        el.style.cssText=`
          position:absolute; left:${t.x}px; top:${t.y}px; transform:translate(-50%,-50%);
          width:104px; height:104px; border-radius: 30px;
          background:#fff; border:6px dashed rgba(0,0,0,.18);
          display:grid; place-items:center; font-size:50px;
        `;
        container.appendChild(el);
      }

      function makePiece(p){
        const el=document.createElement("div");
        el.textContent=p.emoji;
        el.style.cssText=`
          position:absolute; left:${p.x}px; top:${p.y}px; transform:translate(-50%,-50%);
          width:104px; height:104px; border-radius: 30px;
          background:#fff; border:6px solid rgba(0,0,0,.12);
          box-shadow: 0 14px 40px rgba(0,0,0,.20);
          display:grid; place-items:center; font-size:50px;
          touch-action:none; user-select:none;
        `;
        container.appendChild(el);

        let dragging=false, offX=0, offY=0;

        el.onpointerdown=(e)=>{
          if(sid!==miniSessionId) return;
          dragging=true;
          el.setPointerCapture(e.pointerId);
          const r=el.getBoundingClientRect();
          offX = e.clientX - (r.left + r.width/2);
          offY = e.clientY - (r.top  + r.height/2);
          beep(760,0.05,0.04);
        };
        el.onpointermove=(e)=>{
          if(!dragging || sid!==miniSessionId) return;
          const cr=container.getBoundingClientRect();
          el.style.left = `${e.clientX - cr.left - offX}px`;
          el.style.top  = `${e.clientY - cr.top  - offY}px`;
        };
        el.onpointerup=()=>{
          if(sid!==miniSessionId) return;
          dragging=false;

          const er=el.getBoundingClientRect();
          const ex=er.left + er.width/2;
          const ey=er.top  + er.height/2;
          const cr=container.getBoundingClientRect();

          for(const t of targets){
            if(t.emoji!==p.emoji) continue;
            const tx=cr.left + t.x;
            const ty=cr.top  + t.y;
            if(Math.hypot(ex-tx, ey-ty) < 64){
              el.style.left=`${t.x}px`;
              el.style.top =`${t.y}px`;
              el.onpointerdown=el.onpointermove=el.onpointerup=null;
              done++;
              happy();
              if(done>=3) win();
            }
          }
        };
      }
      pieces.forEach(makePiece);
    }
  });

  // Car Wash
  MiniGames.push({
    id:"wash", name:"Car Wash ğŸ§¼",
    start(container, win, sid){
      container.style.position="relative";
      addMiniTip(container,"RUB ğŸ§½ CLEAN!");
      const W=container.clientWidth, H=container.clientHeight;

      const carEl=document.createElement("div");
      carEl.textContent="ğŸš—";
      carEl.style.cssText=`position:absolute; left:50%; top:54%; transform:translate(-50%,-50%); font-size:170px; filter:drop-shadow(0 18px 35px rgba(0,0,0,.25));`;
      container.appendChild(carEl);

      const wash=document.createElement("canvas");
      wash.width=W; wash.height=H;
      wash.style.cssText="position:absolute; inset:0; width:100%; height:100%;";
      container.appendChild(wash);
      const wctx=wash.getContext("2d");

      wctx.fillStyle="rgba(90,70,40,.55)";
      wctx.fillRect(0,0,W,H);

      let cleaned=0;
      let isDown=false;

      function eraseAt(x,y){
        wctx.save();
        wctx.globalCompositeOperation="destination-out";
        wctx.beginPath(); wctx.arc(x,y,50,0,Math.PI*2); wctx.fill();
        wctx.restore();
        cleaned += 2.2;
        if(cleaned > 190) win();
      }

      container.onpointerdown=(e)=>{
        if(sid!==miniSessionId) return;
        isDown=true;
        container.setPointerCapture(e.pointerId);
        beep(760,0.05,0.04);
      };
      container.onpointermove=(e)=>{
        if(!isDown || sid!==miniSessionId) return;
        const r=container.getBoundingClientRect();
        eraseAt(e.clientX-r.left, e.clientY-r.top);
      };
      container.onpointerup=()=>{ isDown=false; };
      container.onpointercancel=()=>{ isDown=false; };
    }
  });

  // Find The Animal
  MiniGames.push({
    id:"find", name:"Find The Animal ğŸ‘€",
    start(container, win, sid){
      container.style.position="relative";
      const animals=["ğŸ±","ğŸ¶","ğŸ¦Š","ğŸ¸","ğŸµ","ğŸ¯","ğŸ¼","ğŸ¦"];
      const target=animals[Math.floor(Math.random()*animals.length)];
      addMiniTip(container, `FIND ${target}`);

      const grid=document.createElement("div");
      grid.style.cssText=`position:absolute; left:50%; top:56%; transform:translate(-50%,-50%);
        display:grid; grid-template-columns: repeat(3, min(30vw, 120px)); gap:14px;`;
      container.appendChild(grid);

      const picks=[target];
      while(picks.length<9) picks.push(animals[Math.floor(Math.random()*animals.length)]);
      for(let i=picks.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [picks[i],picks[j]]=[picks[j],picks[i]];
      }

      picks.forEach(a=>{
        const b=document.createElement("button");
        b.style.cssText=`width:min(30vw,120px); height:min(30vw,120px); border-radius:36px;
          border:4px solid rgba(0,0,0,.10); background:#fff; box-shadow: 0 14px 40px rgba(0,0,0,.20);
          font-size:60px;`;
        b.textContent=a;
        b.onclick=()=>{
          if(sid!==miniSessionId) return;
          if(a===target){ happy(); win(); }
          else{ beep(240,0.08,0.05); b.style.opacity=".35"; }
        };
        grid.appendChild(b);
      });
    }
  });

  // Memory Flip
  MiniGames.push({
    id:"memory", name:"Memory Flip ğŸ§ ",
    start(container, win, sid){
      container.style.position="relative";
      addMiniTip(container, "MATCH 2 SAME!");
      const icons=["ğŸ±","ğŸ¦†","â­"];
      let cards=[...icons,...icons];
      for(let i=cards.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [cards[i],cards[j]]=[cards[j],cards[i]];
      }

      const grid=document.createElement("div");
      grid.style.cssText=`position:absolute; left:50%; top:56%; transform:translate(-50%,-50%);
        display:grid; grid-template-columns: repeat(3, min(28vw, 120px)); gap:14px;`;
      container.appendChild(grid);

      let first=null, lock=false, matched=0;

      function makeCard(icon){
        const b=document.createElement("button");
        b.dataset.icon=icon;
        b.dataset.state="down";
        b.style.cssText=`width:min(28vw,120px); height:min(28vw,120px); border-radius:36px;
          border:4px solid rgba(0,0,0,.10); background:#fff; box-shadow: 0 14px 40px rgba(0,0,0,.20);
          font-size:58px;`;
        b.textContent="â”";
        b.onclick=()=>{
          if(sid!==miniSessionId) return;
          if(lock) return;
          if(b.dataset.state!=="down") return;

          b.dataset.state="up";
          b.textContent=b.dataset.icon;
          beep(740,0.05,0.04);

          if(!first){ first=b; return; }

          if(first.dataset.icon === b.dataset.icon){
            matched++;
            first.dataset.state="matched";
            b.dataset.state="matched";
            first=null;
            happy();
            if(matched>=3) win();
          }else{
            lock=true;
            const a=first;
            first=null;
            miniSetTimeout(()=>{
              if(sid!==miniSessionId) return;
              a.dataset.state="down"; a.textContent="â”";
              b.dataset.state="down"; b.textContent="â”";
              lock=false;
            }, 650, sid);
          }
        };
        return b;
      }
      cards.forEach(icon=>grid.appendChild(makeCard(icon)));
    }
  });

  // Trace The Line
  MiniGames.push({
    id:"trace", name:"Trace The Line âœï¸",
    start(container, win, sid){
      container.style.position="relative";
      addMiniTip(container, "FOLLOW THE PATH!");
      const W=container.clientWidth, H=container.clientHeight;

      const cv=document.createElement("canvas");
      cv.width=W; cv.height=H;
      cv.style.cssText="position:absolute; inset:0; width:100%; height:100%;";
      container.appendChild(cv);
      const g=cv.getContext("2d");

      const path = [
        {x:W*0.18, y:H*0.78},
        {x:W*0.30, y:H*0.56},
        {x:W*0.48, y:H*0.62},
        {x:W*0.64, y:H*0.40},
        {x:W*0.82, y:H*0.48},
      ];

      g.lineCap="round"; g.lineJoin="round";
      g.strokeStyle="rgba(0,0,0,.10)"; g.lineWidth=26;
      g.beginPath(); g.moveTo(path[0].x, path[0].y); for(let i=1;i<path.length;i++) g.lineTo(path[i].x, path[i].y); g.stroke();
      g.strokeStyle="rgba(94,194,255,.90)"; g.lineWidth=18;
      g.beginPath(); g.moveTo(path[0].x, path[0].y); for(let i=1;i<path.length;i++) g.lineTo(path[i].x, path[i].y); g.stroke();
      g.fillStyle="rgba(255,255,255,.95)";
      for(const p of path){ g.beginPath(); g.arc(p.x,p.y,18,0,Math.PI*2); g.fill(); }
      g.font="48px system-ui, Apple Color Emoji, Segoe UI Emoji"; g.textAlign="center"; g.textBaseline="middle";
      g.fillText("ğŸš—", path[0].x, path[0].y-46);
      g.fillText("ğŸ", path[path.length-1].x, path[path.length-1].y-46);

      let idx=0; let down=false;
      const near=(a,b,dist)=>Math.hypot(a.x-b.x, a.y-b.y) < dist;

      container.onpointerdown=(e)=>{ if(sid!==miniSessionId) return; down=true; container.setPointerCapture(e.pointerId); };
      container.onpointermove=(e)=>{
        if(!down || sid!==miniSessionId) return;
        const r=container.getBoundingClientRect();
        const p={x:e.clientX-r.left, y:e.clientY-r.top};
        const target = path[idx];
        if(near(p, target, 45)){
          beep(740,0.05,0.03);
          idx++;
          if(idx>=path.length){ happy(); win(); }
        }
      };
      container.onpointerup=()=>{ down=false; };
      container.onpointercancel=()=>{ down=false; };
    }
  });

  // --- 50 NEW MINI-GAMES (generated from safe templates) ---
  const tapSet = [
    ["tap_apples","Tap Apples ğŸ","ğŸ",16],["tap_bananas","Tap Bananas ğŸŒ","ğŸŒ",14],["tap_grapes","Tap Grapes ğŸ‡","ğŸ‡",16],
    ["tap_cherries","Tap Cherries ğŸ’","ğŸ’",14],["tap_straw","Tap Strawberries ğŸ“","ğŸ“",14],["tap_pear","Tap Pears ğŸ","ğŸ",14],
    ["tap_peach","Tap Peaches ğŸ‘","ğŸ‘",14],["tap_water","Tap Watermelon ğŸ‰","ğŸ‰",14],["tap_lemon","Tap Lemons ğŸ‹","ğŸ‹",14],
    ["tap_candy","Tap Candy ğŸ¬","ğŸ¬",18],["tap_cookie","Tap Cookies ğŸª","ğŸª",16],["tap_donut","Tap Donuts ğŸ©","ğŸ©",14],
    ["tap_ice","Tap Ice Cream ğŸ¦","ğŸ¦",14],["tap_pizza","Tap Pizza ğŸ•","ğŸ•",14],["tap_burger","Tap Burgers ğŸ”","ğŸ”",14],
    ["tap_fries","Tap Fries ğŸŸ","ğŸŸ",14],["tap_ball","Tap Balls âš½","âš½",16],["tap_basket","Tap Basketballs ğŸ€","ğŸ€",16],
    ["tap_tennis","Tap Tennis ğŸ¾","ğŸ¾",16],["tap_baseball","Tap Baseball âš¾","âš¾",16],["tap_rocket","Tap Rockets ğŸš€","ğŸš€",12],
    ["tap_plane","Tap Planes âœˆï¸","âœˆï¸",12],["tap_train","Tap Trains ğŸš‚","ğŸš‚",12],["tap_truck","Tap Trucks ğŸšš","ğŸšš",12],
    ["tap_boat","Tap Boats ğŸš¤","ğŸš¤",12],["tap_fish","Tap Fish ğŸŸ","ğŸŸ",14],["tap_turtle","Tap Turtles ğŸ¢","ğŸ¢",12],
    ["tap_bird","Tap Birds ğŸ¦","ğŸ¦",12],["tap_cat","Tap Cats ğŸ±","ğŸ±",12],["tap_dog","Tap Dogs ğŸ¶","ğŸ¶",12],
    ["tap_frog","Tap Frogs ğŸ¸","ğŸ¸",12],["tap_duck2","Tap Ducks ğŸ¦†","ğŸ¦†",12],["tap_star2","Tap Sparkles âœ¨","âœ¨",16],
    ["tap_heart","Tap Hearts ğŸ’–","ğŸ’–",16],["tap_gift","Tap Gifts ğŸ","ğŸ",14],["tap_light","Tap Lights ğŸ’¡","ğŸ’¡",14],
    ["tap_music","Tap Notes ğŸµ","ğŸµ",16],["tap_cloud","Tap Clouds â˜ï¸","â˜ï¸",12],["tap_sun","Tap Suns â˜€ï¸","â˜€ï¸",12],
    ["tap_moon","Tap Moons ğŸŒ™","ğŸŒ™",12],["tap_planet","Tap Planets ğŸª","ğŸª",12],["tap_rainbow","Tap Rainbows ğŸŒˆ","ğŸŒˆ",12],
    ["tap_flower","Tap Flowers ğŸŒ¼","ğŸŒ¼",14],["tap_tree","Tap Trees ğŸŒ³","ğŸŒ³",12],["tap_car","Tap Cars ğŸš—","ğŸš—",14],
    ["tap_key","Tap Keys ğŸ”‘","ğŸ”‘",14],["tap_bell","Tap Bells ğŸ””","ğŸ””",14],["tap_robot","Tap Robots ğŸ¤–","ğŸ¤–",12],
    ["tap_fire","Tap Fire ğŸ”¥","ğŸ”¥",12],["tap_snow","Tap Snow â„ï¸","â„ï¸",12],
  ];

  // Make 50 tap-spawn games with small variations so they feel different
  tapSet.forEach((t, idx)=>{
    const [id,name,emoji,needed] = t;
    const float = idx % 3 === 0;
    const drift = idx % 3 === 1;
    const life  = idx % 4 === 0 ? 1400 : 0;
    const bg    = idx % 5 === 0
      ? "radial-gradient(circle at 35% 30%, #ffffffcc, #5ec2ff)"
      : idx % 5 === 1
        ? "radial-gradient(circle at 35% 30%, #ffffffcc, #7cffb2)"
        : idx % 5 === 2
          ? "radial-gradient(circle at 35% 30%, #ffffffcc, #ffd27c)"
          : idx % 5 === 3
            ? "radial-gradient(circle at 35% 30%, #ffffffcc, #b48cff)"
            : "radial-gradient(circle at 35% 30%, #ffffffcc, #ff4fa3)";
    createTapSpawnGame({
      id, name, emoji, needed,
      burst: 18,
      minSize: 66, maxSize: 96,
      lifeMs: life,
      float, drift,
      bg,
      label: "TAP",
      respawnWhenLow: 9,
    });
  });

  // Extra variety games (10 more) -> still safe templates
  createTapBigOneGame("good_bad_1","Tap Stars â­ (Not ğŸ’£)","â­","ğŸ’£");
  createTapBigOneGame("good_bad_2","Tap Candy ğŸ¬ (Not ğŸŒ¶ï¸)","ğŸ¬","ğŸŒ¶ï¸");
  createTapBigOneGame("good_bad_3","Tap Fish ğŸŸ (Not ğŸ¦ˆ)","ğŸŸ","ğŸ¦ˆ");
  createTapBigOneGame("good_bad_4","Tap Sun â˜€ï¸ (Not ğŸŒ§ï¸)","â˜€ï¸","ğŸŒ§ï¸");
  createTapBigOneGame("good_bad_5","Tap Hearts ğŸ’– (Not ğŸ’”)","ğŸ’–","ğŸ’”");
  createTapBigOneGame("good_bad_6","Tap Cats ğŸ± (Not ğŸ)","ğŸ±","ğŸ");
  createTapBigOneGame("good_bad_7","Tap Cars ğŸš— (Not ğŸš§)","ğŸš—","ğŸš§");
  createTapBigOneGame("good_bad_8","Tap Gifts ğŸ (Not ğŸ—‘ï¸)","ğŸ","ğŸ—‘ï¸");
  createTapBigOneGame("good_bad_9","Tap Rockets ğŸš€ (Not ğŸª¨)","ğŸš€","ğŸª¨");
  createTapBigOneGame("good_bad_10","Tap Snow â„ï¸ (Not ğŸ”¥)","â„ï¸","ğŸ”¥");

  // Total: original core games + 50 tap games + 10 extra = 60+ mini-games

  function pickMiniGameId(){
    return MiniGames[Math.floor(Math.random()*MiniGames.length)].id;
  }

  // ===== Missions (ALWAYS ONE HELP) =====
  const MissionTypes = [{emoji:"ğŸ±"},{emoji:"ğŸ•"},{emoji:"ğŸ¦†"},{emoji:"â­"},{emoji:"ğŸ”¥"},{emoji:"ğŸ"},{emoji:"ğŸ¸"},{emoji:"ğŸ¦"}];
  let mission = null;
  let activeMission = null;

  function spawnMissionNow(){
    const type = MissionTypes[Math.floor(Math.random()*MissionTypes.length)];
    const t = toys[Math.floor(Math.random()*toys.length)];
    mission = {
      type,
      x: clamp(t.x + (Math.random()*220-110), 120, world.w-120),
      y: clamp(t.y + (Math.random()*220-110), 120, world.h-120),
      pulse: Math.random()*10
    };
  }
  spawnMissionNow();

  function ensureMission(){
    if(!activeMission && !mission) spawnMissionNow();
  }

  function hitMission(wx,wy){
    if(!mission || activeMission) return null;
    if(Math.hypot(wx-mission.x, wy-mission.y) < 110) return mission;
    return null;
  }

  // ===== Confetti =====
  let confetti=[];
  function spawnConfettiAt(wx,wy){
    const p = W2C(wx,wy);
    const colors=["rgba(255,79,163,.95)","rgba(94,194,255,.95)","rgba(124,255,178,.95)","rgba(255,210,124,.95)","rgba(180,140,255,.95)"];
    for(let i=0;i<44;i++){
      confetti.push({
        x:p.x, y:p.y,
        vx:(Math.random()*560-280),
        vy:(Math.random()*-650-240),
        r:Math.random()*Math.PI,
        vr:(Math.random()*10-5),
        size:10+Math.random()*12,
        life:1.0+Math.random()*0.5,
        color: colors[i%colors.length]
      });
    }
  }
  function drawConfetti(dt){
    for(const p of confetti){
      p.vy += 820*dt;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.r += p.vr*dt;
      p.life -= dt;
    }
    confetti = confetti.filter(p=>p.life>0);
    ctx.save();
    for(const p of confetti){
      ctx.save();
      ctx.translate(p.x,p.y);
      ctx.rotate(p.r);
      ctx.globalAlpha = Math.max(0, Math.min(1, p.life));
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.65);
      ctx.restore();
    }
    ctx.restore();
  }

  // ===== Draw world =====
  function roundRect(x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }
  function drawBubble(wx,wy,emoji,label,pulse){
    const p=W2C(wx,wy);
    const s=p.s;
    const r=(62 + Math.sin(pulse)*7)*s;

    ctx.save();
    ctx.globalAlpha=0.22;
    ctx.fillStyle="#000";
    ctx.beginPath(); ctx.ellipse(p.x, p.y+r*0.95, r*0.95, r*0.35, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.fillStyle="rgba(255,255,255,0.94)";
    ctx.strokeStyle="rgba(0,0,0,0.12)";
    ctx.lineWidth=6*s;
    ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill(); ctx.stroke();

    ctx.font = `${Math.floor(44*s)}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillStyle="#111";
    ctx.fillText(emoji, p.x, p.y-2*s);

    ctx.globalAlpha=0.78;
    ctx.font = `${Math.floor(16*s)}px system-ui`;
    ctx.fillText(label, p.x, p.y+r*0.85);
    ctx.restore();
  }

  function drawTown(now){
    ctx.fillStyle="#bff2ff";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // roads grid
    const step=220;
    ctx.save();
    ctx.lineCap="round";
    ctx.strokeStyle="rgba(0,0,0,0.08)";
    ctx.lineWidth=18*fit().s;

    for(let x=0; x<=world.w; x+=step){
      const a=W2C(x,0), b=W2C(x,world.h);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    for(let y=0; y<=world.h; y+=step){
      const a=W2C(0,y), b=W2C(world.w,y);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    ctx.restore();

    // toys
    for(const t of toys){
      const p=W2C(t.x,t.y);
      const s=p.s;
      const bw=t.w*s, bh=t.h*s;
      const yOff=Math.sin(t.bounce)*10*s;

      ctx.save();
      ctx.fillStyle="rgba(255,255,255,0.90)";
      ctx.strokeStyle="rgba(0,0,0,0.10)";
      ctx.lineWidth=6*s;
      roundRect(p.x-bw/2, p.y-bh/2 + yOff, bw, bh, 28*s);
      ctx.fill(); ctx.stroke();

      ctx.font = `${Math.floor(56*s)}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillStyle="#111";
      ctx.fillText(t.emoji, p.x, p.y+yOff);
      ctx.restore();

      t.bounce=Math.max(0,t.bounce-0.10);
    }

    // mini-map
    const dpr = canvas._dpr || 1;
    const pad = 18*dpr;
    const mw = 170*dpr, mh = 120*dpr;
    const x0 = canvas.width - mw - pad;
    const y0 = pad;

    ctx.save();
    ctx.fillStyle="rgba(255,255,255,.90)";
    ctx.strokeStyle="rgba(0,0,0,.10)";
    ctx.lineWidth=5*dpr;
    roundRect(x0,y0,mw,mh,20*dpr);
    ctx.fill(); ctx.stroke();

    const sx = mw / world.w;
    const sy = mh / world.h;

    ctx.font = `${Math.floor(18*dpr)}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText("ğŸš—", x0 + car.x*sx, y0 + car.y*sy);
    if(mission && !activeMission) ctx.fillText("â—", x0 + mission.x*sx, y0 + mission.y*sy);
    ctx.restore();
  }

  function drawCar(){
    const p=W2C(car.x,car.y);
    const s=p.s * car.size;

    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(car.heading);

    ctx.fillStyle="rgba(0,0,0,0.18)";
    ctx.beginPath(); ctx.ellipse(0, 34*s, 44*s, 16*s, 0, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle=car.color;
    ctx.strokeStyle="rgba(0,0,0,0.12)";
    ctx.lineWidth=6*s;
    rr(-46*s, -24*s, 92*s, 58*s, 26*s);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle="rgba(255,255,255,0.55)";
    rr(-14*s, -16*s, 36*s, 26*s, 14*s);
    ctx.fill();

    const ws=s*car.wheel;
    ctx.fillStyle="rgba(0,0,0,0.35)";
    ctx.beginPath(); ctx.arc(-28*s, 32*s, 10*ws, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( 28*s, 32*s, 10*ws, 0, Math.PI*2); ctx.fill();

    ctx.restore();

    function rr(x,y,w,h,r){
      const rr=Math.min(r,w/2,h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }
  }

  // ===== Main loop =====
  let last=performance.now();
  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000);
    last=now;

    // keep help always present when not in active mission
    ensureMission();

    cam.x = clamp(car.x, view.w/2, world.w - view.w/2);
    cam.y = clamp(car.y, view.h/2, world.h - view.h/2);

    if(activeMission){
      const dx = activeMission.x - car.x;
      const dy = activeMission.y - car.y;
      const dist = Math.hypot(dx,dy);
      const speed = 290 * clamp(dist/260, 0.35, 1);
      const nx = dx/(dist||1), ny = dy/(dist||1);
      const targetHeading = Math.atan2(ny,nx);
      car.heading = lerpAngle(car.heading, targetHeading, 0.11);

      const wig = Math.sin(now/160)*0.18;
      car.x += (nx*Math.cos(wig) - ny*Math.sin(wig)) * speed * dt;
      car.y += (ny*Math.cos(wig) + nx*Math.sin(wig)) * speed * dt;

      if(dist < 32){
        const arriveX = activeMission.x, arriveY = activeMission.y;
        activeMission = null;

        spawnConfettiAt(arriveX, arriveY);
        happy();

        face.textContent = "â­";
        title.textContent = "Mini-game!";
        sub.textContent = "Win to get the next HELP bubble";

        startMiniGame(pickMiniGameId(), ()=>{
          showToast("WIN! â­");
          face.textContent = "ğŸš—";
          title.textContent = "Find HELP!";
          sub.textContent = "Tap the bubble (always there!)";
          // âœ… instantly spawn next help
          spawnMissionNow();
        });
      }
    }

    drawTown(now);

    if(mission && !activeMission){
      mission.pulse += 0.08;
      drawBubble(mission.x, mission.y, mission.type.emoji, "HELP!", mission.pulse);
    }

    drawCar();
    drawConfetti(dt);

    requestAnimationFrame(loop);
  }

  // ===== Input =====
  function onTap(clientX, clientY){
    if(garageOverlay.classList.contains("show")) return;
    if(miniOverlay.classList.contains("show")) return;

    const dpr = canvas._dpr || 1;
    const rect = canvas.getBoundingClientRect();
    const px = (clientX - rect.left) * dpr;
    const py = (clientY - rect.top)  * dpr;
    const w = C2W(px,py);

    const m = hitMission(w.x,w.y);
    if(m){
      activeMission = {x:m.x, y:m.y, type:m.type};
      mission = null;           // bubble disappears immediately
      ensureMission();          // but a new one is queued after minigame win
      beep(760,0.05,0.04);
      face.textContent = activeMission.type.emoji;
      title.textContent = "Driving!";
      sub.textContent = "Follow the car ğŸš—";
      return;
    }

    const t = hitToy(w.x,w.y);
    if(t){
      t.bounce = 7.0;
      beep(760,0.05,0.04);
      return;
    }

    currentHorn().play();
  }
  canvas.addEventListener("pointerdown", (e)=> onTap(e.clientX, e.clientY), {passive:true});

  // init
  buildGarageUI();
  previewDraw();
  resize();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
